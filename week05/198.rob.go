package week05

import "math"

// 198. 打家劫舍
// 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
// 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
// 示例 1：
// 输入：[1,2,3,1]
// 输出：4
// 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
//      偷窃到的最高金额 = 1 + 3 = 4 。

// 方法一：动态规划，最容易理解
// 升维思想，因为不知道当前房子偷还是不偷，所以在当前状态上再加一个状态(0,1)标记偷还是不偷
// DP状态数组：dp[i][0,1], i->0..n，二维里的0:偷当前房子，1:不偷当前房子
// DP方程：
// 	不偷第i个房子：dp[i][0] = max(dp[i-1][0], dp[i-1][1]) 解释：第i个房子不偷，不用考虑它的金额，只考虑i-1房子的状态，它也存在2种状态0和1，即可偷可不偷因此取二者较大值即可
// 	偷第i个房子： dp[i][1] = dp[i-1][0] + nums[i] 解释：第i个房子偷，肯定要加上nums[i]的值，另外第i个偷了第i-1个就不能偷了，也就是只能取第i-1个房子状态0的值即dp[i-1][0]
// 由于在dp方程里有2个状态0和1，所以都需要推导
// 时间复杂度：O(n)
// 空间复杂度：O(2n)
func rob1(nums []int) int {
	// 合法性校验
	if nums == nil || len(nums) == 0 {
		return 0
	}
	// max返回a,b中较大者，go标准库需要先转成float64再转回来，略蛋疼
	max := func(a, b int) int {
		if a > b {
			return a
		}
		return b
	}

	n := len(nums)
	// 初始化dp状态数组
	dp := make([][2]int, n)
	// 第1个房子的1种状态，0:不偷，值为0；1:偷，值为nums[0]
	dp[0] = [2]int{0, nums[0]}
	// 根据dp方程递推
	for i := 1; i < n; i++ {
		dp[i][0] = max(dp[i-1][0], dp[i-1][1])
		dp[i][1] = dp[i-1][0] + nums[i]
	}
	return max(dp[n-1][0], dp[n-1][1])
}

// 方法二：dp的2种状态可以简化，用一位数组，简化空间复杂度
// DP状态数组：dp[i]表示从0..i能偷到的最大值，第i个房子可偷可不偷
// DP方程：dp[i] = max(dp[i-1]+0, dp[i-2]+nums[i])
// 解释：如果第i个房子不偷，可以直接从第i-1个房子挪过来即：dp[i-1]；如果第i个房子偷，那么从第i-2个房子挪过来加上nums[i]的值，二者取较大值即可
// 时间复杂度：O(n)
// 空间复杂度：O(n)
func rob2(nums []int) int {
	n := len(nums)
	// 合法性校验
	if len(nums) == 0 {
		return 0
	}
	if n == 1 {
		return nums[0]
	}
	// max返回a,b中较大者，go标准库需要先转成float64再转回来，略蛋疼
	max := func(a, b int) int {
		if a > b {
			return a
		}
		return b
	}

	// 初始化dp状态数组
	dp := make([]int, n)
	// dp[0]表示第1个房子能偷的最大值，肯是nums[0]
	// dp[1]表示第1，2两个房子里能偷到的最大值，因为是相邻的只能偷一个，所以偷较大的一个
	dp[0], dp[1] = nums[0], max(nums[0], nums[1])
	// 根据dp方程递推
	for i := 2; i < n; i++ {
		dp[i] = max(dp[i-1], dp[i-2]+nums[i])
	}
	return dp[n-1]
}

// 方法三：终极优化，类似fibnacci
// 观察可得出递推的过程中，只需要i-1和i-2的值不断迭代，不需要存储全部的值，即为牛逼的思想：滚动数组！！！
// 滚动递推连合法性校验都覆盖了，简直牛逼的不要不要的~~~
// 时间复杂度：O(n)
// 复杂复杂度：O(1)
func rob3(nums []int) int {
	pre, cur := 0, 0
	for _, i := range nums {
		// DP方程：dp[i] = max(dp[i-1]+0, dp[i-2]+nums[i])
		// 迭代过程中，cur即为i-1，pre即为i-1
		pre, cur = cur, int(math.Max(float64(cur), float64(pre+i)))
	}
	return cur
}
