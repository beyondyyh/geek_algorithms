package week06

// 309. 最佳买卖股票时机含冷冻期
// 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​
// 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
// 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
// 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
// 示例:
// 输入: [1,2,3,0,2]
// 输出: 3
// 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
// @lc: https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

// 方法一：动态规划，升维
// DP状态定义：dp[i][j] i:第i天 j:表示是否持有股票，有3种状态
//		j=0：不持股且当天没卖出，定义其最大收益dp[i][0]:
//		j=1：持股，定义其最大收益dp[i][1];
//		j=2：不持股且当天卖出了，定义其最大收益dp[i][2];
// DP转移方程：
//		dp[i][0]=max(dp[i-1][0], dp[i-1][2]) 前一天不持股且当天没有卖出dp[i-1][0] 或者 前一天不持股但是当天卖出去了dp[i-1][2]
//		dp[i][1]=max(dp[i-1][1], dp[i-1][0]-prices[i]) 前一天持股dp[i-1][1] 或者 昨天不持股今天才买入的，前提是前一天没有卖也就是“不持股且当天没卖出”这个状态
//		dp[i][2]=dp[i-1][1]+prices[i] 当天不持股且卖出了
// 最终结果：最后一天“不持股”的2种状态下，返回较大值
func maxProfitWithCooldown(prices []int) int {
	n := len(prices)
	if n == 0 {
		return 0
	}

	// 初始化
	dp := make([][3]int, n)
	dp[0] = [3]int{
		0,          // 本来也不持股，啥玩意儿也不干
		-prices[0], // 第1天买入，收益为负
		0,          // 不持股且当天卖出了，可以理解为买入有卖出了，收益为0
	}
	// 递推
	for i := 1; i < n; i++ {
		dp[i][0] = max(dp[i-1][0], dp[i-1][2])
		dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
		dp[i][2] = dp[i-1][1] + prices[i]
	}
	return max(dp[n-1][0], dp[n-1][2])
}
